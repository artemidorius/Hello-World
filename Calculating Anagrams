// {Solving Question 1a) of BIO 2010}
/* An anagram number is a number that can be multiplied by at least one single digit number (other than 1)
to become an anagram of itself. Any anagrams formed by multiplying an anagram number by a digit are
said to be generated by that anagram number. Two numbers are anagrams of each other if they can both
be formed by rearranging the same combination of digits.
For example:
• 1246878 is an anagram number; multiplying by 6 generates 7481268 or by 7 generates 8728146.
These numbers all contain a single 1, 2, 4, 6, 7 and two 8s.
• 1246879 is not an anagram number. */ 

/*1(a) [ 25 marks ]
Write a program which reads in a single number (between 1 and 123456789 inclusive)
and determines if it is an anagram number.
If the number is not an anagram number you should output the word NO. If it is an
anagram number you should output each single digit it can be multiplied by to make
an anagram of itself.*/

// MY PROPOSED SOLUTION
// process here is: convert the og number into its array of digits, then multiply the number with ever no. between 2 and 9 inclusive, and then store that number's digits in an array
// then pass both arrays into another method which tells you whether the numbers are anagrams of each other or not. 
import java.util.*;
public class so{
    public static boolean isAnagram( int [] a, int [] b){
        int m = a.length; // 1 indexed
        int n = b.length; // might not be the same length
        int [] copy = Arrays.copyOf(a, m);
        if ( m!= n){
            return false;
        }
        int count = 0;
        for (int i = 0; i < n; i++){ // for every no. in multiple
            for(int j = 0; j < m; j++){ // for every orignal no.
              if ( b[i] == copy[j]){
                  count ++; // no. of similarities in the two no.s, must be equal to n ( not n-1 ) for the two to be anagrams of each other
                 copy[j] = -1; // not 0 as the digit could be 0 and we need those
                 break;  //so as to avoid copy[i] matching with same elements present elsewhere and thus double counting
              }
            }
        }
        if ( count == n){ // length of digit
            return true;
        }
        return false;
        }
    public static void main(int n){
        boolean z = false;
        int m = 0;
        String st = Integer.toString(n);
        int s = st.length();
        int [] a = new int[s]; // array for orinigal no. 
        char t;
        char c; 
        for ( int i = 0; i<s; i++){
            t = st.charAt(i);
            a[i] = t - '0';
        } // Digits now stored in array
        int k = 0; 
        String st1 = "";
        for ( int i = 2; i < 10; i++){
            k = n * i; // multiple of n
            st1 = Integer.toString(k);
            int l = st1.length(); 
            int [] b = new int[l]; // array of multiple should be bigger because multiple might not be of the same length of 

            for ( int j = 0; j < l; j ++){
                c = st1.charAt(j);
                b[j] = c - '0';
            } // Digits now in array
            if ( isAnagram(a,b)){ // if even a single digit exists that forms an anagram
                System.out.println(i); // no. it can be multiplied with
                z = true;
            }
        }
        if( z == false){
            System.out.println("NO");
        }
    }
}
    
// Debugs:
/* 1. The 2 numbers ( original and multiple ) might not be of the same length. So the code was modified to take seperate lengths while dealing with array lengths and loop for both arrays. If statement checking whether 
both the numbers have the same length, in which case the code moves fwd, otherwise terminated as 2 anagrams must have the same length */
/* 2. The double loops in isAnagram were wrongly compared along with the if statement too. I accidently rendered spaces in the multiple no. array blank ( -1 ) which was incorrect*/
/* 3. A copy array was made in isAnagram as the -1 blanks changes were reflected in the original array which messed up future iterations. so a copy array with Arrays.copyOf(<name>, <length>) was used*/
/* 4. Said code was not breaking earlier when one digit in the multiple matched with a digit in the orignal no., thus creating double counts for a single element  {2,2,3} and {2,3,4} : the 2 in the second array will register
 2 counts with 2 and 2 again if we dont break*/
/* 5. The code earlier did not declare the b[] array for the multiple in the loop in which the multiple was made in, and was originally initialized with the arbitrary (s+3) to account for extra space as lenght of multiples
might not be the same as length of original no. . this created major issues. so the array was declared everytime indisde the loop and of correct size l measured in the loop. */ 


// TIME COMPLEXITY: O(n^2)



